import fs = require('fs');
import { getWorkspaceDir, QuickOpenFileListDatabaseFile } from "./constants";
import readline = require('readline');
import * as path from 'path';
import { promisify } from 'util';
const readdir = promisify(fs.readdir);
const lstat = promisify(fs.lstat);
import * as vscode from 'vscode';


let file_list: string[] = []
const headline = "# This is database file auto generated by quick file picker, please don't modify it directly\n# You better add it into your project's .gitignore file";


export async function getFileList() {
    // we have already loaded the cache file
    if (file_list.length > 0) {
        return file_list;
    }
    await new Promise((resolve, reject) => {
        var workspaceFolder = getWorkspaceDir();
        var cacheFile = getFileListCache(workspaceFolder);
        fs.lstat(cacheFile, (err) => {
            if (err != null) {
                console.log("filepicker: cache file not exist", err);
                console.timeEnd("filepicker: getFileList");
                resolve();
                return;
            }
            console.time("filepicker: getFileList");
            console.log("filepicker: load file list cache from " + cacheFile)
            const readInterface = readline.createInterface({
                input: fs.createReadStream(cacheFile),
                output: process.stdout,
            });
            const lines: string[] = [];
            readInterface.on('line', function (line: string) {
                if (line.length > 0 && !line.startsWith('#')) {
                    lines.push(line);
                }
            });
            readInterface.on('close', () => {
                console.log("filepicker: file list cacahe loaded");
                console.timeEnd("filepicker: getFileList");
                file_list = lines;
                resolve();
            });
        });
    });
    return file_list;
}

function getFileListCache(workspaceDir: string) {
    return path.join(workspaceDir, QuickOpenFileListDatabaseFile);
}

const property_key_exclude_dirs = "excludeDirs";

export async function addExcludeDirs(newExcludeDirs: string[]) {
    if (cancelExcludeDirs.length == 0) return;

    const currentExcludeDirs = loadExcludedDirs();
    const workspaceDir = getWorkspaceDir();
    // sort the array, make top level directies appear in the front of the array,
    // thus if a top level dir was added into excluded dirs, no  sub-directies of it
    // would be appened to the exclude list. 
    newExcludeDirs.sort((a, b) => a.length - b.length).filter((dir: string) => {
        // assert
        if (!dir.startsWith(workspaceDir)) {
            console.log("filepicker: #updateIncludeAndExcludeDirs, illegal dir: " + dir);
            return false;
        }
        // check if it is already excluded
        if (checkDirExcludedState(dir, currentExcludeDirs).state == Not_Excluded_Yet) {
            currentExcludeDirs.push(dir);
            return true;
        }
        return false;
    });

    if (newExcludeDirs.length == 0) {
        console.log("filepicker: nothing new excluded");
        return;
    }

    saveWorkspaceConfiguration(currentExcludeDirs);


    if (file_list.length == 0) {
        console.log("filepicker: file list not loaded yet");
        vscode.window.showInformationMessage("FilePicker: no search database, don't forget to build it later");
        return;
    }

    // update files list: remove excluded files
    await Promise.all(newExcludeDirs.map((dir) => {
        walkFileTree(dir, currentExcludeDirs, (abs_path: string) => {
            var file = abs_path.replace(workspaceDir, ".");
            console.log("filepicker: remove " + file);
            var index = file_list.indexOf(file);
            if (index >= 0) file_list.splice(index, 1);
        });
    }));
    persistFileListToDisk();
}

export async function cancelExcludeDirs(cancelExcludeDirs: string[]) {
    if (cancelExcludeDirs.length == 0) return;

    const workspaceDir = getWorkspaceDir();
    const currentExcludeDirs = loadExcludedDirs();
    const newDirs: string[] = []
    cancelExcludeDirs.sort((a, b) => a.length - b.length).forEach((dir: string) => {
        // assert
        if (!dir.startsWith(workspaceDir)) {
            console.log("filepicker: #updateIncludeAndExcludeDirs, illegal dir: " + dir);
            return;
        }
        // check if it is already excluded
        var state = checkDirExcludedState(dir, currentExcludeDirs);
        var message = "";
        switch (state.state) {
            case Not_Excluded_Yet: {
                break;
            }
            case ExactlyExcluded: {
                removeElementFromArray(currentExcludeDirs, dir);
                newDirs.push(dir);
                break;
            }
            case ParentDirExcluded: {
                message += "    " + state.extra.replace(workspaceDir, "${workspace}") + "\n";
                break;
            }
        }
        if (message.charAt(message.length - 1) == '\n') {
            message = "fastpicker: please un-exclude the parent directies firstly:\n"
                + message.substr(0, message.length - 1);
            vscode.window.showInformationMessage(message);
        }
    });
    
    if (newDirs.length == 0) {
        console.log("filepicker: #cancelExcludeDirs, nothing canceled");
        vscode.window.showInformationMessage("FilePicker: no search database, don't forget to build it later");
        return;
    }

    saveWorkspaceConfiguration(currentExcludeDirs);

    if (file_list.length == 0) {
        console.log("filepicker: file list not loaded yet");
        return;
    }

    // update file list: index files in those dirs just unexcluded
    await Promise.all(newDirs.map((dir) => {
        walkFileTree(dir, currentExcludeDirs, (abs_path: string) => {
            var file = abs_path.replace(workspaceDir, ".");
            console.log("filepicker: found " + file);
            file_list.push(file);
        });
    }));
   
    persistFileListToDisk();
}


const default_exclude_dirs = [".git", ".repo", ".vscode", ".qfile_picker"];
function loadExcludedDirs() {
    const workspaceDir = getWorkspaceDir();
    let config = vscode.workspace.getConfiguration("filepicker");
    const excludeDirsConfig = config.get("excludeDirs");
    // exclude dirs that user specified
    var excludeDirs = new Set(typeof (excludeDirsConfig) === 'string' ? excludeDirsConfig.split(":").filter((elem: string) => {
        // remove duplicated items and empty string
        return elem.length > 0;
    }) : []);
    var results = [...default_exclude_dirs];
    excludeDirs.forEach((item) => {
        results.push(path.resolve(item.replace("${workspace}", workspaceDir)));
    });
    // exclude all dirs whose names are like the follow pattern
    return results;
}


function saveWorkspaceConfiguration(excludeDirs: string[]) {
    let config = vscode.workspace.getConfiguration("filepicker");
    var excludeDirsConfig = "";
    const workspaceDir = getWorkspaceDir();
    for (var dir of excludeDirs) {
        if (default_exclude_dirs.indexOf(dir) >= 0) {
            // don't wirte defaults
            continue;
        }
        excludeDirsConfig += ":" + dir.replace(workspaceDir, "${workspace}");
    }
    if (excludeDirsConfig.length > 1) {
        excludeDirsConfig = excludeDirsConfig.substring(1);
        config.update(property_key_exclude_dirs, excludeDirsConfig);
    }
}


class FileExcludeState {
    extra = "";
    state = 0;
    constructor(state: number, extra: string) {
        this.state = state;
        this.extra = extra;
    }
}

const Not_Excluded_Yet = 0;
const ExactlyExcluded = 1;
const ParentDirExcluded = 2;
function checkDirExcludedState(newExcludeDir: string, excludedDirs: string[]) {
    var workspaceDir = getWorkspaceDir();
    var dir = newExcludeDir;
    while (dir != workspaceDir) {
        if (excludedDirs.indexOf(dir) >= 0) {
            if (dir == newExcludeDir) {
                return new FileExcludeState(ExactlyExcluded, "");;
            }
            return new FileExcludeState(ParentDirExcluded, dir);;
        }
        dir = path.dirname(dir);
    }
    return new FileExcludeState(Not_Excluded_Yet, "");
}

function removeElementFromArray(nums: string[], elem: string) {
    var index = nums.indexOf(elem);
    if (index >= 0) {
        nums.splice(index, 1);
    }
}

function persistFileListToDisk() {
    var workspaceFolder = getWorkspaceDir();
    const cacheFile = getFileListCache(workspaceFolder);
    const tmpCacheFile = cacheFile + ".new";
    const stream = fs.createWriteStream(tmpCacheFile);
    stream.write(headline);
    file_list.forEach((item: string) => {
        stream.write(item + "\n");
    });
    stream.end();
    fs.rename(tmpCacheFile, cacheFile, () => { });
}

export async function buildFileListCache(onNewFile: any) {
    var excludeDirs = loadExcludedDirs();
    var workspaceFolder = getWorkspaceDir();
    console.time("filepicker: buildFileListCache");
    console.log("filepicker: begin build file list for " + workspaceFolder + ", exclude dirs: " + excludeDirs);
    const tmp_file_list: string[] = []
    const cacheFile = getFileListCache(workspaceFolder);
    const tmpCacheFile = cacheFile + ".new";
    const stream = fs.createWriteStream(tmpCacheFile);
    stream.write(headline)
    // scan all folders in the workspace except those that use manually excluded
    await walkFileTree(workspaceFolder, excludeDirs, (abs_path: string) => {
        var file = abs_path.replace(workspaceFolder, ".");
        // console.log("filepicker: found " + file);
        onNewFile(file);
        tmp_file_list.push(file);
        stream.write(file + "\n");
    });
    stream.end();
    file_list = tmp_file_list;
    console.log("filepicker: found " + tmp_file_list.length + " files");
    console.log("filepicker: wrote cache file list into " + cacheFile);
    console.timeEnd("filepicker: buildFileListCache");
    fs.rename(tmpCacheFile, cacheFile, () => { });
    return cacheFile;
}


function shouldSkipFolder(dir: string/*abs path*/, name: string /*dir name*/, filters: string[] /*abs path*/) {
    // skip hidden folders
    if (name.charAt(0) == '.') {
        return true;
    }
    for (var filter of filters) {
        // and others whose is in the filter
        if (dir === filter || name === filter) {
            return true;
        }
    }
    return false;
}

function shouldSkipFile(name: string, filters: string[] /*abs path*/) {
    return name.charAt(0) == '.';
}

//  filters: string[] /* files in these folers will be indexed */
async function walkFileTree(dir: string, filters: string[], onNewFile: any) {
    const subdirs = await readdir(dir);
    await Promise.all(subdirs.map(async (name: string) => {
        const abs_file = path.join(dir, name);
        var fileStat = await lstat(abs_file);
        if (fileStat.isFile()) {
            if (!shouldSkipFile(name, [])) {
                onNewFile(abs_file);
            }
        } else if (fileStat.isSymbolicLink()) {
            // TODO: follow link?
        } else if (fileStat.isDirectory()) {
            if (!shouldSkipFolder(abs_file, name, filters)) {
                return walkFileTree(abs_file, filters, onNewFile);
            }
            // console.log("filepicker: skip indexing " + abs_file)
        }
        return ""
    }));
    return "";
}